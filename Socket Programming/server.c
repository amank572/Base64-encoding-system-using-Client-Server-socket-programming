#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <arpa/inet.h>
#include <signal.h>
#include <math.h>
#define MAXLINE 1000
#define LISTENQ 10


// stores connected clients ip in this after fork.
char clientname[MAXLINE];

typedef struct Message {
	int type_id;
	char msg[MAXLINE];
} Message;


/**
 returns char array generated by concatanating elements of "struct Message" 
 Format : [MESSAGE_TYPE_ID][MESSAGE_CONTENT]
 **/
char* message_to_char(Message message){
	char *output = (char*) malloc((1+MAXLINE)*sizeof(char));
	output[0] = (char) ((int) '0' + message.type_id);
	int i;
	strcpy(output+1, message.msg);
	return output;
}


/** 
 returns pointers to "struct Message" generated by extracting TYPE_ID and message from input(char array)
 and assigning them to appropriate elements of the "struct Message" 
 **/
Message* char_to_message(char* input){
	Message* output = (Message*) malloc(sizeof(Message));
	strcpy(output->msg, input + 1);
	output->type_id = (int) (input[0] - '0');
	return output;
}


/* converts a char array to an int array by converting each byte to its binary representation and storing this in an int array. Also it adds 0 padding so that total no of bits are divisible by 6. 
blen = length of returned int array
len = length of base64 encoded msg generated by encoding msg.

ex. msg = "ABC";
returns array = {1,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1} 
blen = 21
len = 4
*/
int *char_to_bits(char *msg, int *len, int *blen){
	int n = strlen(msg);
	int sz = n*8;
	if(sz%6)
		sz += (6 -sz%6);
	*len = sz/6;
	if(n%3==1)
		(*len)+=2;
	if(n%3==2)
		(*len)+=1;
	*blen = sz;
	int *bits = (int *)malloc(sz*sizeof(int));
	int idx = 0,i,j;
	for(i = 0;i < n;i++){
		int p  = (int)msg[i];
		for(j=0;j<8;j++){
			bits[idx + 7-j] = (p%2);
			p/=2;
		}
		idx += 8;
	}
	for(i=idx;i<sz;i++)
		bits[i] = 0;
	return bits;
}


// returns corresponding char for each int in base64 encoding.
char mapchar(int i){
    if(i < 26)
        return 'A' + i;
    else if(i < 52)
        return 'a' + i -26;
    else if(i < 62)
        return '0' + i - 52;
    else
        return (i == 62)? '+':'/';
}


/**
 - bits = int array of 1s and 0s only.
 - returns ascii char represented by the binary value from bits[s] to bits[e]
 **/
char binary_to_char(int *bits, int s,int e){
	int p = 0,i;
	for(i=e;i>=s;i--)
		p = p + bits[i]*(1 << e-i);
	return mapchar(p);
}


/**
 - encodes character array data to base64 encoded format
 - returns the encoded data in the original array thus modifying it
 **/
void encode(char*data){
	int f,i,j;
	int n = strlen(data);
	char msg[MAXLINE];
	strcpy(msg, data);

	for(i=0;i<strlen(data);i++){
		if(data[i] == '\r' || data[i] == '\n' || data[i] == '\0'){
			f = i;
			break;
		}
	}
	msg[f] = '\0';

	int encoded_len, bits_len;
	int *bits = char_to_bits(msg, &encoded_len, &bits_len);
	char *encoded_msg = (char*) malloc((encoded_len+n-f+1)*sizeof(char));
	for(i=0;i<bits_len/6;i++)
		encoded_msg[i] = binary_to_char(bits, i*6, i*6 + 5);
	for(i=bits_len/6;i<encoded_len;i++)
		encoded_msg[i] = '=';
	encoded_msg[encoded_len] = '\0';
	int p = encoded_len;
    for(i=p;i<p+(n-f+1);i++)
		encoded_msg[i] = data[f + i-p];
	strcpy(data, encoded_msg);
    free(encoded_msg);
	free(bits);
}


// converts decimal to binary numbers and returns the binary reprsentation in char array temp[i].
void decimalToBinary_d(long n, char temp[][6], int I ) {
    int remainder; 
    int j = 5;
    while(n!=0) {
        remainder = n%2;
        n = n/2;
		if(remainder == 0)		temp[I][j] = '0';
		else					temp[I][j] = '1';
		j--;
    }

    int i;
    for(i=0;i<=j;i++)
	temp[I][i] = '0';

}


// converts a binary array representing an int to its decimal form and return it as int.
int binaryToDecimal_d(char *t ) {
    int decimal = 0, i = 0;
    while (i<8) {
        if(t[7-i] == '1')
        	decimal +=(int) (1 << i);
        ++i;
    }
    return decimal;
 
}


/**
	- makes another copy of the message which contains the whole message except '\r', '\n', '\0'
	- evaluates the length of the original message by the considering the number of '=' appended 
	- translates the encoded binary data into decimal format
	- appends the special characters ('\r' and '\n', '\0') after encoding the content
 **/
void decode(char *msg){
	char EncodedMessage[100000];
	int f,x;
	for(x=0;x<strlen(msg);x++){
		if(msg[x] == '\r' || msg[x] == '\n' || msg[x] == '\0'){
			f = x;
			break;
		}
	}

	for(x=0;x<f;x++)
		EncodedMessage[x] = msg[x];
	EncodedMessage[f] = '\0';
	int len = strlen(EncodedMessage);
	int sub = 0;
	int alen = len;
	if(EncodedMessage[len-1] == '='){
		if(EncodedMessage[len-2] == '='){
			alen = len-2;
			sub = 4;
		}
		else{
			alen = len-1;
			sub = 2;
		}
	}
	alen = (alen*6 - sub)/8;

    char code[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	
	int i,j;
	char temp[100000][6];
	char tempf[600000];

	// bzero(tempf, sizeof(char)*600000);

	for(i=0;i<strlen(EncodedMessage);i++)
		for(j=0;j<=63;j++)
			if(EncodedMessage[i]==code[j])
			{
				decimalToBinary_d(j,temp,i);
				break;
			}	

	int remai = strlen(EncodedMessage) * 6  - strlen(temp[0]);

	if(remai == 6)
	{
		int i;
		for(i=0;i<strlen(temp[0])-2;i++) // removed two 0
			tempf[i] = temp[0][i];
	}
	else if(remai == 12)
	{
		int i;
		for(i=0;i<strlen(temp[0])-4;i++)  // removed four 0
			tempf[i] = temp[0][i];
	}
	else
	{
		int i;
		for(i=0;i<strlen(temp[0]);i++)
			tempf[i] = temp[0][i];
	}


	char DecodedMessage[100000];
	int k = 0;

	int flag = strlen(tempf) / 8;
	int a = flag;
	while(flag)
	{
		char x[8];
		int j;
		for(j=0;j<8;j++)
		    x[j] = tempf[(a-flag)*8 + j];
		
		DecodedMessage[k++] = (char) binaryToDecimal_d(x);
		flag--;
	}

	DecodedMessage[alen] = '\0';
	
	int p = strlen(DecodedMessage);
	int n = strlen(msg);
	for(x=p;x<p+(n-f+1);x++)
		DecodedMessage[x] = msg[f + x-p];
	strcpy(msg, DecodedMessage);
	for(i=0;i< 100000;i++)
		DecodedMessage[i] = '\0';
	for(i=0;i< 600000;i++)
		tempf[i] = '\0';
}


// store parents pid before forking.
pid_t parent_pid;
/* Write "n" bytes to a descriptor. */
ssize_t
writen(int fd, const void *vptr, size_t n)
{
    size_t              nleft;
    ssize_t             nwritten;
    const char  *ptr;

    ptr = (char *)vptr;
    nleft = n;
    while (nleft > 0) {
        if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
            if (errno == EINTR)
                nwritten = 0;           /* and call write() again */
            else
                return(-1);             /* error */
        }

        nleft -= nwritten;
        ptr   += nwritten;
    }
    return(n);
}


// handles writen errors
void Writen(int fd, void *ptr, size_t nbytes){
    if (writen(fd, ptr, nbytes) != nbytes)
        perror("writen error");
}


// returns true if M starts with "close"
bool isClose(char *M){
	if(strlen(M) < 5)
		return false;
	if(M[0] != 'c')
		return false;
	if(M[1] != 'l')
		return false;
	if(M[2] != 'o')
		return false;
	if(M[3] != 's')
		return false;
	if(M[4] != 'e')
		return false;
	return true;
}


typedef struct sockaddr SA;

/**
 - waits for message of client
 - receives the message from client and creates the "Message" object(message) from the received character array(buf)
 - displays client ID, MESSAGE_ID
 - decodes the content the "Message" object
 - creates another "Message" object(smessage) corresponding to "ACK" and store its message type ID and
   content into smessage object
 - translates the message object into character array and sends it to client
**/
void str_server(int sockfd){
	ssize_t n;
	char buf[MAXLINE];
	bzero(buf, MAXLINE*sizeof(char));
	again:
		while((n = read(sockfd, buf, MAXLINE)) > 0){
			Message* message = char_to_message(buf);
			printf("Message received from client %s:\n", clientname);
			printf("Type_id: %d\nmessage: %s\n\n",message->type_id, message->msg);
			printf("Encoded message:%s",message->msg);
			decode(message->msg);
			bool is_close = isClose(message->msg);
			printf("Decoded message:%s",message->msg);
			free(message);
			Message smessage;
			smessage.type_id = 2;
			snprintf(smessage.msg, sizeof(smessage.msg),"ACK\r\n");
			encode(smessage.msg);
			char *message_com = message_to_char(smessage);
			Writen(sockfd, message_com, strlen(message_com));
			free(message_com);
			bzero(buf, sizeof(buf));

			if(is_close){
				printf("client sent close.\n");
				printf("closing socket....\n");
				close(sockfd);
				exit(1);                                                                       // check close server. 
			}
		}
		if(n < 0){
			goto again;
		}
}


// returns true if s is an integer
bool is_int(char *s){
	int i;
	for(i=0;i<strlen(s);i++){
		if(s[i] < '0' || s[i] > '9')
			return false;
	}
	return true;
}


int Lfd,Cfd;

/** 
 used if ctrl-C is pressed to send close signal to client to terminate the servers process serving this client 
 and close open sockets ie release socket resources.
**/
void signalHandler(int signalValue){
	printf("sending close to clients...\n");
	char sendline[MAXLINE];
	bzero(sendline, sizeof(sendline));
	snprintf(sendline, sizeof(sendline), "close\r\n");
	encode(sendline);
	Message message;
	message.type_id = 3;
	strcpy(message.msg, sendline);
	char* message_com = message_to_char(message);
	if(getpid() != parent_pid)
		Writen(Cfd, message_com, strlen(message_com));
	free(message_com);
	if(getpid() == parent_pid)
		printf("closing sockets....\n");
	close(Lfd);
	if(getpid() == parent_pid)
		printf("exiting...\n");
	exit(0);
}


int main(int argc, char **argv){
	parent_pid = getpid();
	signal(SIGINT, signalHandler);
	if(argc != 2){
		printf("usage: <executable> <port>\n");
		exit(1);
	}

	if(!is_int(argv[1])){
		printf("port must be an unsigned integer\n");
		exit(1);
	}	

	int serv_port = atoi(argv[1]);

	if(serv_port < 0 || serv_port > 65535){
		printf("port number must be between 0 and 65535.\n");
		exit(1);
	}

	int listenfd, connfd;
	pid_t child_pid;
	socklen_t cli_len;
	struct sockaddr_in cli_addr, serv_addr;

	printf("Creating socket...\n");
	listenfd = socket(AF_INET, SOCK_STREAM, 0);
	printf("socket created!\n");
	Lfd = listenfd;
	bzero(&serv_addr, sizeof(serv_addr));

	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(serv_port);

	bind(listenfd, (SA *) &serv_addr, sizeof(serv_addr));

	listen(listenfd, LISTENQ);
	printf("listening at port %d\n", serv_port);
	for( ; ; ){
		cli_len = sizeof(cli_addr);
		connfd = accept(listenfd, (SA *) &cli_addr, &cli_len);
		char client[100];
		inet_ntop(AF_INET, &cli_addr.sin_addr, client, 100);
		printf("client %s connected\n", client);
		strcpy(clientname, client);
		if((child_pid = fork()) == 0 ){
			Cfd = connfd;
			close(listenfd);
			str_server(connfd);
			exit(0);
		}

		if(getpid() == parent_pid)
			close(connfd);
	}
	return 0;
}
